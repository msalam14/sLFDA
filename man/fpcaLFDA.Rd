% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SkewedFDA.R
\name{fpcaLFDA}
\alias{fpcaLFDA}
\title{Longitudinal functional data analysis using FPCA}
\usage{
fpcaLFDA(
  Y,
  subject.index,
  visit.index,
  obsT = NULL,
  funcArg = NULL,
  numTEvalPoints = 41,
  newdata = NULL,
  fbps.knots = c(5, 10),
  fbps.p = 3,
  fbps.m = 2,
  mFPCA.pve = 0.95,
  mFPCA.knots = 35,
  mFPCA.p = 3,
  mFPCA.m = 2,
  mFPCA.npc = NULL,
  LongiModel.method = c("fpca.sc", "lme"),
  sFPCA.pve = 0.95,
  sFPCA.nbasis = 10,
  gam.method = "REML",
  gam.kT = 10
)
}
\arguments{
\item{Y}{a matrix of which each row corresponds to one curve observed on a regular and dense grid (dimension of N by m; N = total number of observed functions; m = number of grid points)}

\item{subject.index}{subject id; vector of length N with each element corresponding a row of Y}

\item{visit.index}{index for visits (repeated measures); vector of length N with each element corresponding a row of Y}

\item{obsT}{actual time of visits at which a function is observed; vector of length N with each element corresponding a row of Y}

\item{funcArg}{numeric; function argument}

\item{numTEvalPoints}{total number of equidistant time points where mean function is estimated, defaults to 41}

\item{newdata}{an optional data frame providing predictors (i for subject id / Ltime for visit time) with which prediction is desired; defaults to NULL}

\item{fbps.knots}{list of two vectors of knots or number of equidistanct knots for all dimensions for a fast bivariate P-spline smoothing (fbps) method used to estimate a bivariate, smooth mean function; defaults to c(5,10); see fbps}

\item{fbps.p}{integer;degrees of B-spline functions to use for a fbps method; defaults to 3; see fbps}

\item{fbps.m}{integer;order of differencing penalty to use for a fbps method; defaults to 2; see fbps}

\item{mFPCA.pve}{proportion of variance explained for a mFPCA step; used to choose the number of principal components (PCs); defaults to 0.95; see fpca.face}

\item{mFPCA.knots}{number of knots to use or the vectors of knots in a mFPCA step; used for obtain a smooth estimate of a covariance function; defaults to 35; see fpca.face}

\item{mFPCA.p}{integer; the degree of B-spline functions to use in a mFPCA step; defaults to 3; see fpca.face}

\item{mFPCA.m}{integer;order of differencing penalty to use in a mFPCA step; defaults to 2; see fpca.face}

\item{mFPCA.npc}{pre-specified value for the number of principal components; if given, it overrides pve; defaults to NULL; see fpca.face}

\item{LongiModel.method}{model and estimation method for estimating covariance of estimated scores from a mFPCA step; either KL expansion model or random effects model; defaults to fpca.sc}

\item{sFPCA.pve}{proportion of variance explained for sFPCA step; used to choose the number of principal components; defaults to 0.95; see fpca.sc}

\item{sFPCA.nbasis}{number of B-spline basis functions used in sFPCA step for estimation of the mean function and bivariate smoothing of the covariance surface; defaults to 10; see fpca.sc}

\item{gam.method}{smoothing parameter estimation method when gam is used for predicting score functions at unobserved visit time, T; defaults to REML; see gam}

\item{gam.kT}{dimension of basis functions to use; see gam}

\item{sFPCA.npc}{pre-specified value for the number of principal components; if given, it overrides pve; defaults to NULL; see fpca.sc}
}
\value{
a list with the following items:
\itemize{
 \item obsData: a list of	observed data (input), i: subject id, j: visit index, Tij: observed time points, funcArg: functional argument
 \item funcArg: function argument
 \item visitTime	: visit times
 \item fitted.values	: fitted values (in-sample); of the same dimension as Y
 \item fitted.values.all	: a list of which each component consists of a subject's fitted values at all pairs of evaluation points (s and T)
 \item predicted.values : predicted values for variables provided in newdata
 \item bivariateSmoothMeanFunc	: estimated bivariate smooth mean function
 \item meanFOBJ : fitted object for bi-variate mean function
 \item mcMEAN : fitted mean for marginal covariance
 \item mFPCA.efunctions : estimated eigenfunction in a mFPCA step
 \item mFPCA.evalues	: estimated eigenvalues in a mFPCA step
 \item mFPCA.npc	: number of principal components selected with pre-specified pve in a mFPCA step
 \item mFPCA.scree.eval : estimated eigenvalues obtained with pre-specified pve = 0.9999; for scree plot
 \item sFPCA.xiHat.bySubj :	a list of which each component consists of a subject's predicted score functions evaluated at equidistanced grid in direction of visit time, T
 \item sFPCA.npc	: a vector of numbers of principal components selected in a sFPCA step with pre-specified pve; length of mFPCA.npc
 \item mFPCA.covar	: estimated marginal covariance
 \item sFPCA.longDynCov.k : a list of estimated covariance of score function; length of mFPCA.npc
 \item sigma2k : estimated variance for every k
}
}
\description{
Implements longitudinal functional data analysis (Park and Staicu, 2015). It decomposes longitudinally-observed functional observations in two steps. It first applies FPCA on a properly defined marginal covariance function and obtain estimated scores (mFPCA step). Then it further models the underlying process dynamics by applying another FPCA on a covariance of the estimated scores obtained in the mFPCA step. The function also allows to use a random effects model to study the underlying process dynamics instead of a KL expansion model in the second step. Scores in mFPCA step are estimated using numerical integration. Scores in sFPCA step are estimated under a mixed model framework.
}
\examples{
# This an example of skewed longitudinal functional data where marginal
# is a skew-normal distribution
# Required function for Fourier basis and skew-normal distribution
library(fda)
library(sn)
library(mgcv)
# Population level functions
# Mean function
meanPF<-function(s,t){
  2.5+(3.15*s)+(4*t)+(2*s*t)
}

# Scale Function
sFUN<-function(s,t){
  require(mvtnorm)
  25*dmvnorm(c(s,t),mean = c(0,0),sigma=matrix(c(2.5,0.75,0.75,3.5),2,2))
}

# Shape Function

alFUN<-function(s){
  2e1*(exp(2*s)/(1+exp(2*s)))*sin(6*pi*s/4)
}

# Sbasis functions for $L^2[S]$
SFbasis<-list("sfourier1"=function(s){
  fourier(x=s,nbasis=5,period = 1)[,2]
},"sfourier2"=function(s){
  fourier(x=s,nbasis=5,period = 1)[,3]
},"sfourier3"=function(s){
  fourier(x=s,nbasis=5,period = 1)[,4]
})

# Basis functions for time-dependent coefficients

TBasis<-list(list("tb11" = function(T){fourier(x=T,nbasis=3,period=1)[,2]},
                  "tb12" = function(T){fourier(x=T,nbasis=3,period=1)[,3]}),
             list("tb21" = function(T){fourier(x=T,nbasis=5,period=1)[,4]},
                  "tb22" = function(T){fourier(x=T,nbasis=5,period=1)[,5]}),
             list("tb31" = function(T){fourier(x=T,nbasis=7,period=1)[,6]},
                  "tb32" = function(T){fourier(x=T,nbasis=7,period=1)[,7]})
)


# A set of regular grid in functional domain S
n_s<-51
ss<-seq(0,1,length.out = n_s)

# Eigen values for time-dependent coefficient $eta_{kl}$
tdcfV<-list(c(0.6,0.4),c(0.5,0.3),c(0.25,0.20))


# Variance parameters
sig2_S<-c(0.328,0.210,0.046)
sig2_E<-0.183


# Testing 
ntp<-20
tp<-matrix(seq(0,1,length.out = ntp+2)[-c(1,ntp+2)],ncol=1)

# Full process time grid
Tg<-seq(0,1,length.out=51)

## number of subjects
n<-25

# Selection of mi
mi<-sapply(1:n,sample,x=6:12,size = 1)

# Observed Time points
Tij<-lapply(seq_len(length(mi)), function(w){sort(sample(Tg,mi[w]))})

# Simulation of Skewed FD
gdata<-SNFData(argS = ss,TimePoint = Tij,Sbasis = SFbasis,Tbasis = TBasis,
               Eta = tdcfV,Sigma2K = sig2_S,Sigma2 = sig2_E,
               muF = meanPF,sclF = sFUN,alpF = alFUN)


# Fitting lfda model

lfda_fit<-fpcaLFDA(Y=do.call(rbind,gdata$Y), subject.index=rep(1:n,mi), 
         visit.index=do.call(c,lapply(1:n, function(i){1:mi[i]})), 
         obsT = do.call(c,Tij), funcArg = ss, numTEvalPoints = 51, 
         newdata = NULL, fbps.knots = c(20, 10), fbps.p = 3, fbps.m = 2, 
         mFPCA.pve = 0.95, mFPCA.knots = 20, mFPCA.p = 3, mFPCA.m = 2, 
         mFPCA.npc = NULL, LongiModel.method = "fpca.sc", sFPCA.pve = 0.95, 
         sFPCA.nbasis = 10, gam.method = "REML", gam.kT = 10)

}
